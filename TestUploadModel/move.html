<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>


    <script type="module">


        import * as THREE from './build/three.module.js';

       
        import Stats from './build/stats.module.js';

        import { OrbitControls } from './build/OrbitControls.js';
        import { FBXLoader } from './build/FBXLoader.js';

        let camera, scene, renderer, stats;

        const clock = new THREE.Clock();

        let mixer;
        let mixer2;

        init();
        animate();

        function init() {

            const container = document.createElement( 'div' );
            document.body.appendChild( container );

            camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
            camera.position.set( 100, 200, 300 );

            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xa0a0a0 );
            //scene.fog = new THREE.Fog( 0xa0a0a0, 200, 1000 );

            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
            hemiLight.position.set( 0, 200, 0 );
            scene.add( hemiLight );

            const dirLight = new THREE.DirectionalLight( 0xffffff );
            dirLight.position.set( 0, 200, 100 );
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 180;
            dirLight.shadow.camera.bottom = - 100;
            dirLight.shadow.camera.left = - 120;
            dirLight.shadow.camera.right = 120;
            scene.add( dirLight );

            // scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );

            // ground
            const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
            mesh.rotation.x = - Math.PI / 2;
            mesh.receiveShadow = true;
            scene.add( mesh );

            const grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            scene.add( grid );

            // model
     
            const loader1 = new FBXLoader();
            loader1.load( '/TestUploadModel/ZombieAnim/zombieoneidle.fbx', function ( object ) {
                

                mixer = new THREE.AnimationMixer( object );
                object.scale.multiplyScalar(0.5); 

                const action = mixer.clipAction( object.animations[ 0 ] );
                action.play();

                object.traverse( function ( child ) {

                    if ( child.isMesh ) {

                        child.castShadow = true;
                        child.receiveShadow = true;

                    }

                } );

                scene.add( object );

            } );

                 
           const loader2 = new FBXLoader();
            loader2.load( '/TestUploadModel/ZombieAnim/zombieonewalk.fbx', function ( object ) {
                

                mixer2 = new THREE.AnimationMixer( object );
                object.scale.multiplyScalar(0.5); 
                object.position.x=300;
                const action = mixer2.clipAction( object.animations[ 0 ] );
                action.play();

                object.traverse( function ( child ) {

                    if ( child.isMesh ) {

                        child.castShadow = true;
                        child.receiveShadow = true;

                    }

                } );

                scene.add( object );

            } );
            
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.shadowMap.enabled = true;
            container.appendChild( renderer.domElement );

            const controls = new OrbitControls( camera, renderer.domElement );
            controls.target.set( 0, 0, 0 );
            controls.update();

            window.addEventListener( 'resize', onWindowResize );

            // stats
            stats = new Stats();
            container.appendChild( stats.dom );

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        //

        function animate() {

            requestAnimationFrame( animate );

            const delta = clock.getDelta();

            if ( mixer ) mixer.update( delta );
            if ( mixer2 ) mixer2.update( delta );

            renderer.render( scene, camera );

            stats.update();

        }

    </script>

</body>
</html>

